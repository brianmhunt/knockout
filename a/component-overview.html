<!doctype html>
<html manifest='ko.appcache'>
<head>
  <!-- auto generated from  markdown/component-overview.html -->
  <meta charset='utf-8'>
  <title> Knockout.js </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href='build/styles.css' rel='stylesheet' type='text/css' />
</head>
<body data-bind='css.bound: true'>
  <div class='headline'>
    <img src="build/hourglass.gif" alt='Loading ...'/>
    <div class='browser-version'>
      Please ensure you are using the latest version of a modern
      browser. If this page fails to load, you may still access
      the <a href='http://knockoutjs.com'>legacy documentation site</a>.
    </div>
  </div>

  <div style='display: none' data-bind='style.display: 'block''>
    {{# template: 'header' /}}
    <div class='main'>
      {{# if: body }}
        <h1>{{ title }}</h1>
        <div data-bind='animatedTemplate: body' class='main-body'></div>
      {{/if }}
      {{# ifnot: body }}
        <h1>Component Overview</h1>
        <div class='main-body'>
<!-- /header -->
<p><strong>Components</strong> are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</p>
<ul>
<li>...can represent individual controls/widgets, or entire sections of your application</li>
<li>...contain their own view, and usually (but optionally) their own viewmodel</li>
<li>...can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</li>
<li>...can receive parameters, and optionally write back changes to them or invoke callbacks</li>
<li>...can be composed together (nested) or inherited from other components</li>
<li>...can easily be packaged for reuse across projects</li>
<li>...let you define your own conventions/logic for configuration and loading</li>
</ul>
<p>This pattern is beneficial for large applications, because it <strong>simplifies development</strong> through clear organization and encapsulation, and helps to <strong>improve runtime performance</strong> by incrementally loading your application code and templates as needed.</p>
<p><strong>Custom elements</strong> are an optional but convenient syntax for consuming components. Instead of needing placeholder <code>&lt;div&gt;</code>s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., <code>&lt;voting-button&gt;</code> or <code>&lt;product-editor&gt;</code>). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</p>
<h3 id="example-a-like-dislike-widget">Example: A like/dislike widget</h3>
<p>To get started, you can register a component using <code>ko.components.register</code> (technically, registration is optional, but it&#39;s the easiest way to get started). A component definition specifies a <code>viewModel</code> and <code>template</code>. For example:</p>
<p><live-example params='id: "component-like"'></live-example></p>
<p><strong>Normally, you&#39;d load the view model and template from external files</strong> instead of declaring them inline like this. We&#39;ll get to that later.</p>
<p>Now, to use this component, you can reference it from any other view in your application, either using the <a href="#component-binding"><code>component</code> binding</a> or using a <a href="#component-custom-elements">custom element</a>. Here&#39;s a live example that uses it as a custom element:</p>
<p><live-example params='id: "component-overview"'></live-example></p>
<p>In this example, the component both displays and edits an observable property called <code>userRating</code> on the <code>Product</code> view model class.</p>
<h3 id="example-loading-the-like-dislike-widget-from-external-files-on-demand">Example: Loading the like/dislike widget from external files, on demand</h3>
<p>In most applications, you&#39;ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as <a href="http://requirejs.org/">require.js</a>, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</p>
<p>Here&#39;s an example configuration:</p>
<pre><code class="lang-javascript"><div data-bind='highlight: "javascript"'>ko.components.register('like-or-dislike', {
    viewModel: { require: 'files/component-like-widget' },
    template: { require: 'text!files/component-like-widget.html' }
});</div>
</code></pre>
<p><strong>Requirements</strong></p>
<p>For this to work, the files <a href="files/component-like-widget.js"><code>files/component-like-widget.js</code></a> and <a href="files/component-like-widget.html"><code>files/component-like-widget.html</code></a> need to exist. Check them out (and <em>view source</em> on the <code>.html</code> one) - as you&#39;ll see, this is cleaner and more convenient that including the code inline in the definition.</p>
<p>Also, you need to have referenced a suitable module loader library (such as <a href="http://requirejs.org/">require.js</a>) or implemented a <a href="component-loaders.html">custom component loader</a> that knows how to grab your files.</p>
<p><strong>Using the component</strong></p>
<p>Now <code>like-or-dislike</code> can be consumed in the same way as before, using either a <a href="#component-binding"><code>component</code> binding</a> or a <a href="#component-custom-elements">custom element</a>:</p>
<pre><code class="lang-html"><div data-bind='highlight: "html"'>&lt;ul data-bind="foreach: products">
    &lt;li class="product">
        &lt;strong data-bind="text: name">&lt;/strong>
        &lt;like-or-dislike params="value: userRating">&lt;/like-or-dislike>
    &lt;/li>
&lt;/ul>
&lt;button data-bind="click: addProduct">Add a product&lt;/button></div>
</code></pre>
<pre><code class="lang-javascript"><div data-bind='highlight: "javascript"'>function Product(name, rating) {
    this.name = name;
    this.userRating = ko.observable(rating || null);
}

function MyViewModel() {
    this.products = ko.observableArray(); // Start empty
}

MyViewModel.prototype.addProduct = function() {
    var name = 'Product ' + (this.products().length + 1);
    this.products.push(new Product(name));
};

ko.applyBindings(new MyViewModel());</div>
</code></pre>
<p>If you open your browser developer tools&#39; <strong>Network</strong> inspector before your first click on <em>Add product</em>, you&#39;ll see that the component&#39;s <code>.js</code>/<code>.html</code> files are fetched on demand when first required, and thereafter retained for reuse.</p>
<h3 id="learn-more">Learn more</h3>
<p>More more detailed information, see:</p>
<ul>
<li><a href="#component-registration">Defining and registering components</a></li>
<li><a href="#component-binding">Using the <code>component</code> binding</a></li>
<li><a href="#component-custom-elements">Using custom elements</a></li>
<li><a href="#component-loaders">Advanced: Custom component loaders</a></li>
</ul>
<!-- footer -->
        </div>
      {{ /ifnot }}
    </div>
    {{# template: 'footer' /}}
  </div>
  <script src='build/libs.js'></script>
  <script src='build/app.js' async></script>
</body>
</html>
