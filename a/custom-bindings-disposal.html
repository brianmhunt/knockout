<!doctype html>
<html manifest='ko.appcache'>
<head>
  <!-- auto generated from  markdown/custom-bindings-disposal.html -->
  <meta charset='utf-8'>
  <title> Knockout.js </title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href='build/styles.css' rel='stylesheet' type='text/css' />
</head>
<body data-bind='css.bound: true' data-version="b4c2ee4">
  <div class='headline'>
    <img src="build/hourglass.gif" alt='Loading ...'/>
    <div class='browser-version'>
      Please ensure you are using the latest version of a modern
      browser. If this page fails to load, you may still access
      the <a href='http://knockoutjs.com'>legacy documentation site</a>.
    </div>
  </div>

  <div style='display: none' data-bind='style.display: 'block''>
    {{# template: 'header' /}}
    <div class='main'>
      {{# if: body }}
        <h1>{{ title }}</h1>
        {{# template: body /}}
      {{/if }}
      <div data-bind='ifnot: body'>
        <h1>Custom disposal logic</h1>
<!-- /header -->
<p>In a typical Knockout application, DOM elements are dynamically added and removed, for example using the <a href="template-binding.html"><code>template</code></a> binding or via control-flow bindings (<a href="if-binding.html"><code>if</code></a>, <a href="ifnot-binding.html"><code>ifnot</code></a>, <a href="with-binding.html"><code>with</code></a>, and <a href="foreach-binding.html"><code>foreach</code></a>). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.</p>
<h3 id="registering-a-callback-on-the-disposal-of-an-element">Registering a callback on the disposal of an element</h3>
<p>To register a function to run when a node is removed, you can call <code>ko.utils.domNodeDisposal.addDisposeCallback(node, callback)</code>. As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the <code>destroy</code> method of the widget:</p>
<pre><code class="lang-javascript"><div data-bind='highlight: "javascript"'>ko.bindingHandlers.myWidget = {
    init: function(element, valueAccessor) {
        var options = ko.unwrap(valueAccessor()),
            $el = $(element);

        $el.myWidget(options);

        ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
            // This will be called when the element is removed by Knockout or
            // if some other part of your code calls ko.removeNode(element)
            $el.myWidget("destroy");
        });
    }
};</div>
</code></pre>
<h3 id="overriding-the-clean-up-of-external-data">Overriding the clean-up of external data</h3>
<p>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&#39;s <code>cleanData</code> method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, <code>ko.utils.domNodeDisposal.cleanExternalData(node)</code>, that can be overridden to support custom logic. For example, to prevent <code>cleanData</code> from being called, an empty function could be used to replace the standard <code>cleanExternalData</code> implementation:</p>
<pre><code class="lang-javascript"><div data-bind='highlight: "javascript"'>ko.utils.domNodeDisposal.cleanExternalData = function () {
    // Do nothing. Now any jQuery data associated with elements will
    // not be cleaned up when the elements are removed from the DOM.
};</div>
</code></pre>
<!-- footer -->
      </div>
    </div>
    {{# template: 'footer' /}}
  </div>
  <script src='build/libs.js'></script>
  <script src='build/app.js' async></script>
</body>
</html>
